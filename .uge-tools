#
# UGE Cluster
#

alias qbad='qstat -f | awk "{if (NF > 5) print}"'
alias qslots='qstat -g c'
alias qerr='qstat -qs E -f -explain E | awk "/^---*$/ { print \"\"; next} /^queuename/ { print \"\$1, \$6, error job node\"; next } /^[^ ]*@/ { node_info=\"$1 - $6\"; next } { print node_info $0 }" | sed "s/\.ihme\.wash.[^ ]*//g; s/\t*queue [^ ]* marked / - /; s/ as result of / - /; s/.s failure at host / - on /"'
alias qqlogins='qstat -u \* | egrep "(QLOGIN|qlogins@)" | sort -k4 | awk "{ if (\$9 >= 10 && \$5 == \"r\") printf \"%d %-8s %10s %8s %s %d\n\", \$1, \$4, \$6, \$7, \$8, \$9, \$NF}"'

#TODO add manual messages
alias qexplain='for state in E a; do qstat -f -qs $state -explain $state; done'

#redirect qconf help to STDOUT and grep for the arg
alias qwhat='qconf -help 2>&1 | grep'

#show idle logins
#find all job IDs in the qlogins@ queue and find ones that are not using any memory
#TODO add CPU time
#TODO does this actually work?
qidle () {
	for job in `qstat -u \* | grep 'qlogins@' | awk '{ print $1 }'`; do
		qstat -j $job
	done | awk '/^job_number/ { job=$NF; slots=1} /^owner/ { user=$NF } /^parallel environment/ { slots=$NF } /^exec_host_list/ { FS="," } /^usage/ { if ( $3 == " mem=0.00000 GBs") { printf "%-10d %3d %-8s %-10s %-15s\n", job, slots, user, $2, $5} FS=" "}'
}

#check if a cluster node is configured
function check_node () {
	local node=$1

	local QUEUE="all.q"
	local HOST_GROUP="@allhosts"

	local admin=`qconf -sh | grep $node`
	local exec=`qconf -sel | grep $node`
	local submit=`qconf -ss | grep $node`
	local host_grp=`qconf -shgrp $HOST_GROUP | grep $node | sed 's/^ *//'`
	local queue=`qconf -sq $QUEUE | grep $node`

	printf "%-12s: %s\n" "admin host" $admin
	printf "%-12s: %s\n" "exec host" $exec
	printf "%-12s: %s\n" "submit host" $submit
	printf "%-12s: %s\n" "host group" "$host_grp"
	printf "%-12s: %s\n" "queue" $queue
}

#search UGE project-related configurations
function qproj_probe () {
    # This only greps for a substring. It does not look up RQS and UL
    # based on the project configuration
    local func_name=${FUNCNAME[0]}

    if (( $# != 1 )); then
        echo "Usage: $func_name <string>"
        return 1
    fi

    local sub_string=$1

    echo "Projects matching '$sub_string'"
    echo "---------------------------------------------------"
    # list matching projects
    for proj in `qconf -sprjl | grep -i $sub_string`; do
        qconf -sprj $proj
        echo
    done |
    # grep out "default" values to shorten output
    egrep -v '((fshare|oticket) *0$|xacl *NONE$)'

    echo "User Lists matching '$sub_string'"
    echo "---------------------------------------------------"
    # list matching user lists
    for user_list in `qconf -sul | grep -i $sub_string`; do
        qconf -su $user_list
        echo
    done |
    egrep -v '((fshare|oticket) *0$|xacl *NONE$|type *ACL$)'

    echo "Resource Quota Sets matching '$sub_string'"
    echo "---------------------------------------------------"
    # list matching resource quota sets
    for resource_quota in `qconf -srqsl | grep -i $sub_string`; do
        qconf -srqs $resource_quota
        echo
    done |
    egrep -v '(enabled *TRUE$|{|})' |
    sed 's/^ *//'
}

#check for running jobs on a node
function qhjobs () {
    local func_name=${FUNCNAME[0]}

    if (( $# > 1 )); then
        echo "Usage: $func_name [HOSTNAME] (default: current host)"
        return 1
    fi

    if (( $# == 0 )); then
        node=`hostname -s`
    else
        node=$1
    fi

    qhost -j -h $node
}
