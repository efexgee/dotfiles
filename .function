#print a slice of a file, N lines long starting at line M
buckets () {
    # $1 : rsync command line file
    # $2 : starting line (starting bucket number)
    # $3 : number of lines (number of buckets)

    if (( $# != 3 )); then
        echo "Usage: $0 <rsync commands file> <number of buckets> <start bucket id>"
        return 1
    elif [ ! -f $1 ]; then
        echo "File not found: $1"
        return 2
    fi

    file=$1
    number=$2
    start=$3

    tail -n +${start} $file | head -${number}

    echo
    echo "Printed $1: lines $start - $(($start + $number - 1))"
}

#print summary of all rsyncs' status
rsync_report () {
    finished=0
    output=`for log_file in \`ls -1 *.log\`; do
        tail=\`tail -1 $log_file\`
        if ! echo $tail | grep sent > /dev/null; then
            lines=\`wc -l $log_file | cut -d\  -f1\`
        else
            lines="?"
        fi
        label=${log_file/.log/}
        printf "%s %8s : $tail\n" $label $lines
        done`
    echo "$output" | egrep -v "(] sent |rsync error)" | cut -c1-`tput cols`
    building=`echo "$output" | grep -c "building file list"`
    error=`echo "$output" | grep -c "rsync error"`
    finished=`echo "$output" | grep -c "] sent"`
    echo
    other=$(( `echo "$output" | wc -l` - $finished - $building - $error ))
    printf "Building: %3d\nError: %6d\nOther: %6d\nComplete: %3d\n" $building $error $other $finished
}

function githubbify () {
    #requires:
    #    user definition in .ssh/config
    #    ssh key in .ssh
    #    an API token for GitHub
    #    the token defined as a git variable called github.token
    if (( $# != 2 )); then
        echo "Usage: $0 <repo name> <repo description>"
        return
    fi

    local user=efexgee
    #github.token is not a standard git field, I think
    local gh_token=`git config github.token`

    local name=$1
    local descr=$2

    local remote="gh.$name"

    local curl_data='{"name":"'$name'","description":"'$descr'"}'


    echo "Creating new repo ($remote) on GitHub..."
    curl -u $user:$gh_token https://api.github.com/user/repos -d "$curl_data" || return 1

    echo "Adding GitHub repo as a remote..."
    git remote add $remote ssh://github.com/$user/$name || return 2

    echo "Pushing local Git repo to GitHub repo..."
    git push --set-upstream $remote master || return 3
    echo "Done."
}

#shove an existing git repo into IHME's Bitbucket
function bbify () {
    #requires:
    if (( $# != 1 )); then
        echo "Usage: $0 <repo name>"
        return
    fi

    local user=$USER
    local name=$1

    local URL="stash.ihme.washington.edu"

    local remote="ihme.$name"

    local curl_data='{"name":"'$name'","scmId":"git"}'
    local curl_header='Content-Type: application/json'

    echo "Creating new repo ($remote) on BitBucket..."
    curl -u $user https://$URL/rest/api/1.0/users/$user/repos -H "$curl_header" -X POST -d "$curl_data" || return 1

    echo "Adding BitBucket repo as a remote..."
    git remote add $remote "ssh://git@$URL:7999/~$user/$name.git" || return 2

    echo "Pushing local Git repo to BitBucket: $remote"
    git push --set-upstream $remote master || return 3
    echo "Done."
}


#list all running rsyncs, deriving a label from the logfile name
function rsync_ps () {
    if [ "$1" = "-u" ]; then
        #ps h -C rsync k -etime -o etime,tty,wchan:23,args | sed "s/rsync .*--log-file \([^ ]*\)\.log .*/\1/" | sort -k4 | uniq -s 47
        ps h -C rsync k -etime -o etime,tty,args | sed "s#pts/##; s/ *rsync .*--log-file \([^ ]*\)\.log .*/ \1/" | sort -k3 | uniq -s 14 | sed 's/ \([0-9]\) /  \1 /'
    else
        ps h -C rsync k -s,-etime -o s,etime,tty,wchan:23,args | sed "s/rsync .*--log-file \([^ ]*\)\.log .*/\1/" | sort -k5 | egrep "(^[RT]|$)"
    fi
}

#list all running tars, deriving a label from the archive name
function tar_ps () {
    ps h -C tar k -etime -o etime,tty,args | sed "s#pts/##; s/ *tar .* \([^ ]*\)\.tar .*/ \1/" | sort -k3 | uniq -s 14 | sed 's/ \([0-9]\) /  \1 /'
}

#list all running rm's
function rm_ps () {
    if [ "$1" = "-u" ]; then
        ps h -C rm k -etime -o etime,tty,wchan:23,args | sort -k4 | uniq -s 47
    else
        ps h -C rm k -s,-etime -o s,etime,tty,wchan:23,args | sort -k5 | egrep "(^[RT]|$)"
    fi
}

#condense rsync log
function rsync_log () {
        local func_name=${FUNCNAME[0]}

    if (( $# != 1 )); then
        echo "Usage: $func_name <rsync log file>"
        return 1
    fi

    local log_file=$1

    (head -1 $log_file
    tail -100 $log_file | egrep '(Number of files transferred|Total transferred file size)'
    tail -1 $log_file) |
    sed 's/\[[^]]*\] //; s/Number of files transferred:/Files /; s/Total transferred file size:/Size  /'
}

#rename qsplit buckets
function fix_buckets () {
    local func_name=${FUNCNAME[0]}

    if (( $# != 1 )); then
        echo "Usage: $func_name <new bucket prefix>"
        return 1
    fi
    

    if [ ! -f qsync_* ]; then
        echo "Usage: $func_name <new bucket prefix> (must be run in a directory with qsplit buckets)"
        echo "Error: No bucket files found"
        return 1
    fi
    
    local bucket

    for bucket in `ls qsync*bucket*`; do
        local bucket_id=`echo $bucket | sed "s/qsync_[0-9_]*\.bucket_\([0-9]*\)/\1/"`
        #bucket_id=`printf "%02d" $bucket_id`
        mv -v $bucket ${1}_bucket_$bucket_id
    done

    echo "Updating bucket timestamps"

    # timestamp the buckets to match order
    for bucket in `ls ${1}_bucket*`; do
        touch $bucket
        sleep 0.01
    done
}

#search UGE project-related configurations
#ssh and name your screen window for that host
function scsh () {
    local func_name=${FUNCNAME[0]}

    if ! (( $# == 1 || $# == 2)); then
        echo "Usage: $func_name <hostname>"
        return 1
    fi

    local host=$1

    if screen -X version > /dev/null 2>&1; then
        screen -X title "$(printf "%2s - %s" $(basename $(tty)) $host)"
    fi

    ssh $host
}
