#print a slice of a file, N lines long starting at line M
buckets () {
	# $1 : rsync command line file
	# $2 : starting line (starting bucket number)
	# $3 : number of lines (number of buckets)

	if (( $# != 3 )); then
		echo "Usage: $0 <rsync commands file> <number of buckets> <start bucket id>"
		return 1
	elif [ ! -f $1 ]; then
		echo "File not found: $1"
		return 2
	fi

	file=$1
	number=$2
	start=$3

	tail -n +${start} $file | head -${number}

	echo
	echo "Printed $1: lines $start - $(($start + $number - 1))"
}

#print summary of all rsyncs' status
rsync_report () {
	finished=0
	output=`for log_file in \`ls -1 *.log\`; do
		tail=\`tail -1 $log_file\`
		if ! echo $tail | grep sent > /dev/null; then
			lines=\`wc -l $log_file | cut -d\  -f1\`
		else
			lines="?"
		fi
		label=${log_file/.log/}
		printf "%s %8s : $tail\n" $label $lines
		done`
	echo "$output" | egrep -v "(] sent |rsync error)" | cut -c1-`tput cols`
	building=`echo "$output" | grep -c "building file list"`
	error=`echo "$output" | grep -c "rsync error"`
	finished=`echo "$output" | grep -c "] sent"`
	echo
	other=$(( `echo "$output" | wc -l` - $finished - $building - $error ))
	printf "Building: %3d\nError: %6d\nOther: %6d\nComplete: %3d\n" $building $error $other $finished
}

#print percent complete on boom migration
boom_mig_progress () {
	df /qumulo/boom-fs/node_06/forecasting/ /qumulo/dengue-fs/node_06/forecasting/ --output=target,used |
	awk '/boom-fs/ { boom = $NF } /dengue-fs/ { dengue = $NF } END { printf "%3.1f%% complete\n", dengue / boom * 100 }'
}

#log into a Qumulo cluster
qql () {
	local API_PASSWORD="qapi"

	local cluster="${1}-fs"
	local user="${cluster}-api"
	local qq_c="--host $cluster"
	local qq_cred="--credentials-store $HOME/.qfsd_cred.$cluster"

	qq $qq_cred $qq_c login -u $user -p $API_PASSWORD > /dev/null

	if [ $? -eq 0 ]; then
		host=`qq $qq_cred $qq_c cluster_conf | jq -r '.cluster_name'`
		login=`qq $qq_cred $qq_c who_am_i | jq -r '.name' 2> /dev/null`
		echo "${login} @ ${host}"
	else
		echo "Couldn't log into $cluster [Exit code: $?]"
	fi
}

#log into a Qumulo cluster as admin
qqla () {

	local cluster="${1}-fs"
	local user="admin"
	local qq_c="--host $cluster"
	local qq_cred="--credentials-store $HOME/.qfsd_cred.$cluster"

	echo -n "$cluster Admin "
	qq $qq_cred $qq_c login -u $user > /dev/null

	if [ $? -eq 0 ]; then
		host=`qq $qq_cred $qq_c cluster_conf | jq -r '.cluster_name'`
		login=`qq $qq_cred $qq_c who_am_i | jq -r '.name' 2> /dev/null`
		echo "${login} @ ${host}"
	else
		echo "Couldn't log into $cluster [Exit code: $?]"
	fi
}

#show idle logins
#find all job IDs in the qlogins@ queue and find ones that are not using any memory
#TODO add CPU time
qidle () {
	for job in `qstat -u \* | grep 'qlogins@' | awk '{ print $1 }'`; do
		qstat -j $job
	done | awk '/^job_number/ { job=$NF; slots=1} /^owner/ { user=$NF } /^parallel environment/ { slots=$NF } /^exec_host_list/ { FS="," } /^usage/ { if ( $3 == " mem=0.00000 GBs") { printf "%-10d %3d %-8s %-10s %-15s\n", job, slots, user, $2, $5} FS=" "}'
}

#get size and file count of a directory via Qumulo API
function qq_size () {
	if (( $# != 1 )); then
		echo "Usage: ${FUNCNAME[0]} <full Qumulo path>"
		return 1
	fi

	if ! echo $1 | grep -q '^/'; then
		echo "${FUNCNAME[0]}: path needs to start with a slash"
		return 2
	fi

	qqb fs_read_dir_aggregates --path $1 |
	jq -r '[(.total_data | tonumber), (.total_files | tonumber), (.total_directories | tonumber), (.path | split("/"))[-2]] | @csv' |
	tr -d '"' |
	awk -F, '{printf "%10'\''.1f Gb %12'\''d files  %s\n", $1 / 1024^3, $2 + $3, $4}'
}

#get size and file count of a directory via Qumulo API
function qq_sizes () {
	local func_name=${FUNCNAME[0]}
	local max_entries=5000

	if (( $# > 2 )); then
		echo "Usage: $func_name [ <Qumulo cluster> <full Qumulo path> ]"
		return 1
	fi

	if (( $# == 1 )); then
		echo "Usage: $func_name [ <Qumulo cluster> <full Qumulo path> ]"
		echo "Error: Either specify both cluster and path, or neither to use current location"
		return 5
	fi

	if (( $# == 2 )); then
		local cluster=$1
		local path=$2
	else
		local cluster=`host \`df --output=source . | tail -1 | cut -d\: -f1\` | awk -F'[ .]' '{print $10}'`
		local path=`pwd | sed "s#\`dirname \\\`df --output=target . | tail -1\\\`\`##"`
	fi

	local token_file=~/.qfsd_cred.${cluster}

	if ! [ -f $token_file ]; then
		echo "$func_name: token file doesn't seem to exist: $token_file"
		return 4
	fi

	if ! $(echo $path | grep -q '^/'); then
		echo "$func_name: path needs to start with a slash"
		return 2
	fi 

	local qq_output=`qq --host $cluster --credentials-store $token_file who_am_i`

	if $(echo $qq_output | grep -q Error); then
		echo "$func_name: Error talking to $cluster. Is there an established session?"
		return 3
	fi

	local qq_login=`echo $qq_output | jq -r '.name' 2> /dev/null`

	if ! [ "$qq_login" = "admin" ]; then
		echo "$func_name: Warning: Not logged in as admin (login = $qq_login). Some paths won't be accessible."
		echo
	fi

	qq --host $cluster --credentials-store $token_file fs_read_dir_aggregates --max-entries $max_entries --path $path |
	jq -r '.files[] | [(.data_usage | tonumber), (.num_files | tonumber), (.num_directories | tonumber), .name] | @csv' |
	tr -d '"' |
	awk -F, '{printf "%10'\''.1f Gb %12'\''d files  %s\n", $path / 1024^3, $2 + $3, $4}'
}

#do the same thing but make CSVs
function qq_sizes_csv () {
	local func_name=${FUNCNAME[0]}
	local max_entries=5000

	if (( $# > 2 )); then
		echo "Usage: $func_name [ <Qumulo cluster> <full Qumulo path> ]"
		return 1
	fi

	if (( $# == 1 )); then
		echo "Usage: $func_name [ <Qumulo cluster> <full Qumulo path> ]"
		echo "Error: Either specify both cluster and path, or neither to use current location"
		return 5
	fi

	if (( $# == 2 )); then
		local cluster=$1
		local path=$2
	else
		local cluster=`host \`df --output=source . | tail -1 | cut -d\: -f1\` | awk -F'[ .]' '{print $10}'`
		local path=`pwd | sed "s#\`dirname \\\`df --output=target . | tail -1\\\`\`##"`
	fi

	local token_file=~/.qfsd_cred.${cluster}

	if ! [ -f $token_file ]; then
		echo "$func_name: token file doesn't seem to exist: $token_file"
		return 4
	fi

	if ! $(echo $path | grep -q '^/'); then
		echo "$func_name: path needs to start with a slash"
		return 2
	fi 

	local qq_output=`qq --host $cluster --credentials-store $token_file who_am_i`

	if $(echo $qq_output | grep -q Error); then
		echo "$func_name: Error talking to $cluster. Is there an established session?"
		return 3
	fi

	local qq_login=`echo $qq_output | jq -r '.name' 2> /dev/null`

	if ! [ "$qq_login" = "admin" ]; then
		echo "$func_name: Warning: Not logged in as admin (login = $qq_login). Some paths won't be accessible."
		echo
	fi

	qq --host $cluster --credentials-store $token_file fs_read_dir_aggregates --max-entries $max_entries --path $path |
	jq -r '.files[] | [(.data_usage | tonumber) / 1024 / 1024 / 1024, (.num_files | tonumber) + (.num_directories | tonumber), .name] | @csv' |
    tr -d '"'
}
#get size and number of directories
function qq_dirs () {
	local func_name=${FUNCNAME[0]}
	local max_entries=5000

	if (( $# > 2 )); then
		echo "Usage: $func_name [ <Qumulo cluster> <full Qumulo path> ]"
		return 1
	fi

	if (( $# == 1 )); then
		echo "Usage: $func_name [ <Qumulo cluster> <full Qumulo path> ]"
		echo "Error: Either specify both cluster and path, or neither to use current location"
		return 5
	fi

	if (( $# == 2 )); then
		local cluster=$1
		local path=$2
	else
		local cluster=`host \`df --output=source . | tail -1 | cut -d\: -f1\` | awk -F'[ .]' '{print $10}'`
		local path=`pwd | sed "s#\`dirname \\\`df --output=target . | tail -1\\\`\`##"`
	fi

	local token_file=~/.qfsd_cred.${cluster}

	if ! [ -f $token_file ]; then
		echo "$func_name: token file doesn't seem to exist: $token_file"
		return 4
	fi

	if ! $(echo $path | grep -q '^/'); then
		echo "$func_name: path needs to start with a slash"
		return 2
	fi 

	local qq_output=`qq --host $cluster --credentials-store $token_file who_am_i`

	if $(echo $qq_output | grep -q Error); then
		echo "$func_name: Error talking to $cluster. Is there an established session?"
		return 3
	fi

	local qq_login=`echo $qq_output | jq -r '.name' 2> /dev/null`

	if ! [ "$qq_login" = "admin" ]; then
		echo "$func_name: Warning: Not logged in as admin (login = $qq_login). Some paths won't be accessible."
		echo
	fi

	qq --host $cluster --credentials-store $token_file fs_read_dir_aggregates --max-entries $max_entries --path $path |
	jq -r '.files[] | [(.data_usage | tonumber), (.num_directories | tonumber), .name] | @csv' |
	tr -d '"' |
	awk -F, '{printf "%10'\''.1f Gb %12'\''d dirs  %s\n", $path / 1024^3, $2, $3}'

}

#shove an existing git repo into my personal GitHub account
function githubbify () {
	#requires:
	#	user definition in .ssh/config
	#	ssh key in .ssh
	#	an API token for GitHub
	#	the token defined as a git variable called github.token
	if (( $# != 2 )); then
		echo "Usage: $0 <repo name> <repo description>"
		return
	fi

	local user=efexgee
	#github.token is not a standard git field, I think
	local gh_token=`git config github.token`

	local name=$1
	local descr=$2

	local remote="gh.$name"

	local curl_data='{"name":"'$name'","description":"'$descr'"}'


	echo "Creating new repo ($remote) on GitHub..."
	curl -u $user:$gh_token https://api.github.com/user/repos -d "$curl_data" || return 1

	echo "Adding GitHub repo as a remote..."
	git remote add $remote ssh://github.com/$user/$name || return 2

	echo "Pushing local Git repo to GitHub repo..."
	git push --set-upstream $remote master || return 3
	echo "Done."
}

#list all running rsyncs, deriving a label from the logfile name
function rsync_ps () {
	if [ "$1" = "-u" ]; then
		#ps h -C rsync k -etime -o etime,tty,wchan:23,args | sed "s/rsync .*--log-file \([^ ]*\)\.log .*/\1/" | sort -k4 | uniq -s 47
		ps h -C rsync k -etime -o etime,tty,args | sed "s#pts/##; s/ *rsync .*--log-file \([^ ]*\)\.log .*/ \1/" | sort -k3 | uniq -s 14 | sed 's/ \([0-9]\) /  \1 /'
	else
		ps h -C rsync k -s,-etime -o s,etime,tty,wchan:23,args | sed "s/rsync .*--log-file \([^ ]*\)\.log .*/\1/" | sort -k5 | egrep "(^[RT]|$)"
	fi
}

#list all running rm's
function rm_ps () {
	if [ "$1" = "-u" ]; then
		ps h -C rm k -etime -o etime,tty,wchan:23,args | sort -k4 | uniq -s 47
	else
		ps h -C rm k -s,-etime -o s,etime,tty,wchan:23,args | sort -k5 | egrep "(^[RT]|$)"
	fi
}

#condense rsync log
function rsync_log () {
        local func_name=${FUNCNAME[0]}

	if (( $# != 1 )); then
		echo "Usage: $func_name <rsync log file>"
		return 1
	fi

	local log_file=$1

	(head -1 $log_file
	tail -100 $log_file | egrep '(Number of files transferred|Total transferred file size)'
	tail -1 $log_file) |
	sed 's/\[[^]]*\] //; s/Number of files transferred:/Files /; s/Total transferred file size:/Size  /'
}

#rename qsplit buckets
function fix_buckets () {
	local func_name=${FUNCNAME[0]}

	if (( $# != 1 )); then
		echo "Usage: $func_name <new bucket prefix>"
		return 1
	fi
	

	if [ ! -f qsync_* ]; then 
		echo "Usage: $func_name <new bucket prefix> (must be run in a directory with qsplit buckets)"
		echo "Error: No bucket files found"
		return 1
	fi
	
	local bucket

	for bucket in `ls qsync*bucket*`; do
		local bucket_id=`echo $bucket | sed "s/qsync_[0-9_]*\.bucket_\([0-9]*\)/\1/"`
		#bucket_id=`printf "%02d" $bucket_id`
		mv -v $bucket ${1}_bucket_$bucket_id
	done

	echo "Updating bucket timestamps"

	# timestamp the buckets to match order
	for bucket in `ls ${1}_bucket*`; do
		touch $bucket
		sleep 0.01
	done
}

#check if a cluster node is configured
function check_node () {
	local node=$1

	local QUEUE="all.q"
	local HOST_GROUP="@allhosts"

	local admin=`qconf -sh | grep $node`
	local exec=`qconf -sel | grep $node`
	local submit=`qconf -ss | grep $node`
	local host_grp=`qconf -shgrp $HOST_GROUP | grep $node | sed 's/^ *//'`
	local queue=`qconf -sq $QUEUE | grep $node`

	printf "%-12s: %s\n" "admin host" $admin
	printf "%-12s: %s\n" "exec host" $exec
	printf "%-12s: %s\n" "submit host" $submit
	printf "%-12s: %s\n" "host group" "$host_grp"
	printf "%-12s: %s\n" "queue" $queue
}

#compare qq_sizes on two different Qumulos
function qq_comp () {
    local path=$1;
    local left=blah-fs;
    local right=chagas-fs;

    echo $left;
    qq_sizes $left $path;

    echo $right;
    qq_sizes $right $path;
}

#list all snapshots and their sizes
function qq_snaps () {
	local func_name=${FUNCNAME[0]}

	if (( $# != 1 )); then
		echo "Usage: $func_name <qumulo cluster name>"
		return 1
	fi

    local cluster=$1

    for snap in `(echo Total; qq --credentials-store ~/.qfsd_cred.${cluster} --host $cluster snapshot_list_snapshots | jq -r '.entries[] | .id')`; do
        if [ "$snap" == "Total" ]; then
            size=`qq --credentials-store ~/.qfsd_cred.${cluster} --host $cluster snapshot_get_total_used_capacity | jq -r '.bytes'`
        else
            size=`qq --credentials-store ~/.qfsd_cred.${cluster} --host $cluster snapshot_calculate_used_capacity --id $snap | jq -r '.bytes'`
        fi

        echo "$snap $size"
    done | awk '{printf "%5s %'\''10.1f Gb\n", $1, $2 / 1024 ^ 3}'
}

#search UGE project-related configurations
function qproj_probe () {
    # This only greps for a substring. It does not look up RQS and UL
    # based on the project configuration
    local func_name=${FUNCNAME[0]}

    if (( $# != 1 )); then
        echo "Usage: $func_name <string>"
        return 1
    fi

    local sub_string=$1

    echo "Projects matching '$sub_string'"
    echo "---------------------------------------------------"
    # list matching projects
    for proj in `qconf -sprjl | grep -i $sub_string`; do
        qconf -sprj $proj
        echo
    done |
    # grep out "default" values to shorten output
    egrep -v '((fshare|oticket) *0$|xacl *NONE$)'

    echo "User Lists matching '$sub_string'"
    echo "---------------------------------------------------"
    # list matching user lists
    for user_list in `qconf -sul | grep -i $sub_string`; do
        qconf -su $user_list
        echo
    done |
    egrep -v '((fshare|oticket) *0$|xacl *NONE$|type *ACL$)'

    echo "Resource Quota Sets matching '$sub_string'"
    echo "---------------------------------------------------"
    # list matching resource quota sets
    for resource_quota in `qconf -srqsl | grep -i $sub_string`; do
        qconf -srqs $resource_quota
        echo
    done |
    egrep -v '(enabled *TRUE$|{|})' |
    sed 's/^ *//'
}

#check for running jobs on a node
function qhjobs () {
    local func_name=${FUNCNAME[0]}

    if (( $# > 1 )); then
        echo "Usage: $func_name [HOSTNAME] (default: current host)"
        return 1
    fi

    if (( $# == 0 )); then
        node=`hostname -s`
    else
        node=$1
    fi

    qhost -j -h $node
}

#wrapper around Qumulo agg_tree_diff
function qq_diff () {
    local func_name=${FUNCNAME[0]}

    if ! (( $# == 1 || $# == 2)); then
        echo "Usage: $func_name <path> <-v,-vv,-vvv>"
        return 1
    fi

    if (($# == 2)); then
        local verbose=$2
    fi

    #local ID=$RANDOM
    local SRC_CLUSTER="blah-fs"
    local DEST_CLUSTER="chagas-fs"

    local path=$1
    local path_label=`echo $path | sed 's#^/##' | tr '/' '.'`

    local outfile_prefix="agg_diff.$path_label.$ID"
    local dirs_output="$outfile_prefix.dirs"
    local files_output="$outfile_prefix.files"

    #~falko/scripts/agg_diff/agg_diff.py --host-src $SRC_CLUSTER --cred-store-src ~/.qfsd_cred.$SRC_CLUSTER --host-target $DEST_CLUSTER --cred-store-target ~/.qfsd_cred.$DEST_CLUSTER --path $path --dirs-out-file $dirs_output --files-out-file $files_output $verbose
    ~falko/scripts/agg_diff/agg_diff.py -r -f --host-src $SRC_CLUSTER --cred-store-src ~/.qfsd_cred.$SRC_CLUSTER --host-target $DEST_CLUSTER --cred-store-target ~/.qfsd_cred.$DEST_CLUSTER --path $path $verbose

    #more $dirs_output
}

