#print a slice of a file, N lines long starting at line M
buckets () {
	# $1 : rsync command line file
	# $2 : starting line (starting bucket number)
	# $3 : number of lines (number of buckets)

	if (( $# != 3 )); then
		echo "Usage: $0 <rsync commands file > <start bucket id> <number of buckets>"
		return 1
	elif [ ! -f $1 ]; then
		echo "File not found: $1"
		return 2
	fi

	file=$1
	start=$2
	number=$3

	tail -n +${start} $file | head -${number}
}

#print summary of all rsyncs' status
rsync_report () {
	finished=0
	output=`for log_file in \`ls -1 *.log\`; do
		tail=\`tail -1 $log_file\`
		if ! echo $tail | grep sent > /dev/null; then
			lines=\`wc -l $log_file | cut -d\  -f1\`
		else
			lines="?"
		fi
		label=${log_file/.log/}
		printf "%s %8s : $tail\n" $label $lines
		done`
	echo "$output" | egrep -v "(] sent |rsync error)" | cut -c1-`tput cols`
	building=`echo "$output" | grep -c "building file list"`
	error=`echo "$output" | grep -c "rsync error"`
	finished=`echo "$output" | grep -c "] sent"`
	echo
	other=$(( `echo "$output" | wc -l` - $finished - $building - $error ))
	printf "Building: %3d\nError: %6d\nOther: %6d\nComplete: %3d\n" $building $error $other $finished
}

#print percent complete on boom migration
boom_mig_progress () {
	df /qumulo/boom-fs/node_06/forecasting/ /qumulo/dengue-fs/node_06/forecasting/ --output=target,used |
	awk '/boom-fs/ { boom = $NF } /dengue-fs/ { dengue = $NF } END { printf "%3.1f%% complete\n", dengue / boom * 100 }'
}

#log into a Qumulo cluster
qql () {
	local API_PASSWORD="qapi"

	local cluster="${1}-fs"
	local user="${cluster}-api"
	local qq_c="--host $cluster"
	local qq_cred="--credentials-store $HOME/.qfsd_cred.$cluster"

	qq $qq_cred $qq_c login -u $user -p $API_PASSWORD > /dev/null

	if [ $? -eq 0 ]; then
		host=`qq $qq_cred $qq_c cluster_conf | jq -r '.cluster_name'`
		login=`qq $qq_cred $qq_c who_am_i | jq -r '.name' 2> /dev/null`
		echo "${login} @ ${host}"
	else
		echo "Couldn't log into $cluster [Exit code: $?]"
	fi
}

#show idle logins
#find all job IDs in the qlogins@ queue and find ones that are not using any memory
#TODO add CPU time
qidle () {
	for job in `qstat -u \* | grep 'qlogins@' | awk '{ print $1 }'`; do
		qstat -j $job
	done | awk '/^job_number/ { job=$NF; slots=1} /^owner/ { user=$NF } /^parallel environment/ { slots=$NF } /^exec_host_list/ { FS="," } /^usage/ { if ( $3 == " mem=0.00000 GBs") { printf "%-10d %3d %-8s %-10s %-15s\n", job, slots, user, $2, $5} FS=" "}'
}

#get size and file count of a directory via Qumulo API
function qq_size () {
	if (( $# != 1 )); then
		echo "Usage: ${FUNCNAME[0]} <full Qumulo path>"
		return 1
	fi

	if ! echo $1 | grep -q '^/'; then
		echo "${FUNCNAME[0]}: path needs to start with a slash"
		return 2
	fi

	qqb fs_read_dir_aggregates --path $1 |
	jq -r '[(.total_capacity | tonumber), (.total_files | tonumber), (.total_directories | tonumber), (.path | split("/"))[-2]] | @csv' |
	tr -d '"' |
	awk -F, '{printf "%10'\''.1f Gb %12'\''d files  %s\n", $1 / 1024^3, $2 + $3, $4}'
}

#get size and file count of a directory via Qumulo API
function qq_sizes () {
	if (( $# != 1 )); then
		echo "Usage: ${FUNCNAME[0]} <full Qumulo path>"
		return 1
	fi

	if ! echo $1 | grep -q '^/'; then
		echo "${FUNCNAME[0]}: path needs to start with a slash"
		return 2
	fi

	qqb fs_read_dir_aggregates --path $1 |
	jq -r '.files[] | [(.capacity_usage | tonumber), (.num_files | tonumber), (.num_directories | tonumber), .name] | @csv' |
	tr -d '"' |
	awk -F, '{printf "%10'\''.1f Gb %12'\''d files  %s\n", $1 / 1024^3, $2 + $3, $4}'

}
